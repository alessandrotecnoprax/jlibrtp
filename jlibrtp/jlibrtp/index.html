<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html><head><title>jlibrtp - Java RTP Library</title>



<meta name="author" content="Arne Kepp">
<meta name="keywords" content="jlibrtp, java, rtp, streaming, voip">
<meta name="description" content="jlibrtp is an implementation of RFC 3550, the Real-Time Transport Protocol, in Java."></head><body bgcolor="white">

<h1>jlibrtp - Java RTP Library</h1>
<address>
<a href="http://kepp.net">Arne Kepp</a><br>
Columbia University<br>
New York, NY 10027<br>
USA<br>
<a href="mailto:ak2618@columbia.edu">ak2618@columbia.edu</a>
</address>
<p>
</p><address>
Vaishnav Janardhan<br>
Columbia University<br>
New York, NY 10027<br>
USA<br>
<a href="mailto:vj2135@columbia.edu">vj2135@columbia.edu</a>
</address>

<h2><a name="abstract">Abstract</a></h2>

<p>We have created a library that partially implements the Real-Time Transport Protocol (RTP), 
a well-established standard for streaming media across IP-based networks, in Java. The purpose 
of this library is to make it easy for application developers to create applications for peer 
to peer streaming of audio, video and other data. In addition, developers will need a protocol 
to establish contact with peers, such as Session Initialization Protocol (SIP).</p>

<p>Our library accepts any kind of binary data, handles packet parsing and reordering, maintains a 
participant database and the control connection associated with the protocol. The application 
is notified of received data through a callback-interface. The library supports IPv4, IPv6 and 
multicast. It does currently not support encryption, and should not be used in cases where 
confidentiality is important.</p>

<h2><a name="introduction">Introduction</a></h2>
<p>jlibrtp partially implements the Real-Time Transport Protocol (RTP, RFC 3550)<a href="#1">[1]</a>. 
It is an alternative to the RTP stack provided by Sun Microsystems (R) in the Java Media Framework 
(JMF)<a href="#2">[2]</a>,  the difference is that we attempt to provide application developers with a much 
simpler application programming interface (API).</p>

<p>To use jlibrtp, developers must instatiate a copy of the RTPSession class and provide a class 
that implements the callback interface RTPAppIntf. The RTPSession object is a container for the 
datastructures required by the library,  and starts the threads used for receiving and parsing 
packets. The program can use simple methods to add peers, participants  that send or receive 
packets, to the session. The callback interface is called whenever the stack has data ready for 
the application, and it is up to the developer to decide what to do with the binary data.</p>

<p>Our code is licensed under the GNU Lesser General Public License (LGPL)<a href="#3">[3]</a>, 
developers are therefore free to change functionality or provide a richer API if the current implementation 
does not meet their needs.</p>

<h3>Structure of Report</h3>
<ul>
<li><a href="#abstract">Abstract</a></li>

<li><a href="#introduction">Introduction</a></li>

<li><a href="#related_work">Related Work</a></li>

<li><a href="#background">Background</a></li>

<li><a href="#program_documentation">Program Documentation</a>
<ul>
<li><a href="#architecture">Architecture</a>
<ul>
<li><a href="#architecture_overview">Overview</a></li>
<li><a href="#architecture_rtp">RTP</a></li>
<li><a href="#architecture_rtcp">RTCP</a></li>
</ul>
</li>
<li><a href="#api">Advanced Programming Interface (API)</a></li>
<li><a href="#example_application">Example Application</a></li>
<li><a href="#demo_application">Demonstration Application</a></li>
<li><a href="#security">Security</a></li>
</ul>
</li>
<li><a href="#measurements">Measurements</a>
<ul>
<li><a href="#performance">Performance</a></li>
<li><a href="#interoperability">Interoperability</a></li>
</ul>
</li>
<li><a href="#task_list">Task List</a>
<li><a href="#references">References</a>
</ul>
</p><h2><a name="related_work">Related Work</a></h2>
<p>The Java Media Framework provides much of the same functionality as jlibrtp, 
but requires the application developer to do considerably more work and cannot 
easily be modified to accomodate special requirements.</p>

<p>JRTP<a href="#4">[4]</a> is a framework for media distribution that also includes RTP. 
However, it is a  comprehensive program for the distribution of content, such as television, 
and the RTP component is not designed to be used separately. It appears that it was
last modified in 1997 and is therefore probably outdated.</p>

<p>java.net.rtp<a href="#5">[5]</a> is a relatively old application specialized for a
whiteboard application. It only supports multicast, which currently severly limits its 
usefulness in common VoIP applications, and lacks the datastructures to 
handle separate streams.</p>

<p>There are several RTP stacks available in C and C++, including GNU Telephony's ccRTP<a href="#6">[6]</a></p>

</p><h2><a name="background">Background</a></h2>

<p>RTP is often used to refer to both the data (RTP packets) and the associated 
signalling protocol, RTCP (Real-Time Transport Control Protocol). Less sophisticated applications 
are generally only concerned with the data. RTCP provides functionality to monitor the flow of data
and generates statistics for both senders and receivers. This information can be used to limit
the bandwidth used, by detecting the loss of packets. Clients could for example switch to a more
compact encoding scheme so that everyone in a session is able to keep up.</p>
<p>The two sub-protocols operate on separate UDP ports (uni- or multicast), both of which must be 
communicated to peers through a medium like SIP (Session Initialization Protocol).</p>

</p><h2><a name="program_documentation">Program Documentation</a></h2>
</p><h3><a name="architecture">Architecture</a></h3>
</p><h4><a name="architecture_overview">Overview</a></h4>
<p>At the heart of our code is the RTPSession object. It provides handles to
all the other datastructures we use, namely the RTP receiver thread, the database
of participants, the thread that calls the application when new data is available,
and the associated RTCP session. Developers that want to use this library should
only have to know about the RTPSession object and associated methods, our model of
a participant, and implement the callback interface RtpAppIntf.</p>

<p>We have attempted to maintain a relatively small footprint and therefore only
include code from the standard Java libraries provided by Sun Microsystems. The
application was developed using Java Developer kit version 1.5.0, but it should
work in environments using 1.4.2 as well. The code does not rely on any features
that are specific to any platform and is written entirely in Java.</p>

<p>It was somewhat difficult to implement RTP in Java. The language does not support
unsigned integers, which RTP uses lots of. Instead we use 64 bit longs internally,
which we convert to byte-arrays before transmitting. Java passes arrays
of primitives by value, packet parsing therefore becomes relatively expensive.</p>

</p><h4><a name="architecture_rtp">RTP</a></h4>
<p>The RTPSession object handles the sending of data synchronously. The idea is
that we want to space the packets out in time as much as possible. Tests showed that
making it asynchronous tended to create bursts of packets. On the receiving end there
is a single thread listening on the specified UDP port. Once a packet is received it
is parsed, a number of tests applied and then put into the packet buffer of the
corresponding participant. The receiver thread is blocked until the next packet arrives.
</p>
<p>The packet buffer is a linked list. It reorders packets that arrive out of order
and can recombine multiple packets into frames based on sequence numbers. A separate
thread, called the AppCallerThread, is signalled every time a packet is added to a buffer.
It then loops over all the participants that we expect to receive packets from and calls
the receiveData() method, which is implemted by the application. This call is also
synchronous by design, but can easily be made asynchronous by the application developer.
</p>
<p>The participant database is implemented as three hashtables, containing receivers,
sender and unknown senders, keyed on SSRC for fast retrieval. Unknown senders are
created in cases where we receive packets from sources that the application for some
reason has not added as participants. The application developer specifies whether these 
packets should be rejected, which is de default, or handed to the application.
</p>

</p><h4><a name="architecture_rtcp">RTCP</a></h4>
<p>RTCP is the control protocol associated with RTP protocol. RTCP provides support for periodic reporting reporting of reception
of quality, participant identification and other source description information, notification on changes in session membership.<p>

<p><b>RTCP implementation has three parts:</b></br>
	1. The 4 different packet formats.</br>
	2. Sending and receiving formats.</br>	
	3. Participant database and statistics collection.<p>


		<img src="vaish1.png" /></br>


<p>Here in the RTCP module there is only one receiver thread, which will start to listen on the RTCP port and receive all the 
RTCP packets meant for that particular participant. Once the packet is received the packet will be decoded and appopriate 
information will be displayed to the user. On the similar lines, the RTCP will send the packets periodically when ever the 
appropriate timer fires to all the participants in the participant database. The sender thread for any of the RTCP packet 
format will build a packet with the statistics information and send the collected statistics to every participant in the
RTCP session. In this particular model, the transport port and the statistics for every participant will be maintained in the
Participant database. RTCP session is the main class of the RTCP session which will start all the different RTCP threads and
also RTCP receiver thread for receiving of the messages.<p>

<p>Totally 4 different send threads have been implemented which will be started by the RTCP session class. These four different 
threads will send out their respective packets periodically when the timer fires. When the timer fires the statistics till that
moment will be encapsulated in the packet and sent to all the participants.</p>

<p>RTCP will transport the packets through the unicast socket to the rtcp port of the RTP session participant. Usually the RTCP
port should be configured to be a port number one more than the RTP session. The RTCP socket will be initialised only once and
the same socket will be used to send the data to all the participants.</p>

<p><b>Different RTCP messages:</b></br>
RTCP protocol defines a total of 5 different messages, but in this particular model only 4 different messages have
been implemented. The Application defined message has been ommited. The general RTCP packet format is common for all the four
different messages. The general packet format is as given below.</p>

<b>RTCP Common Header</b></br>
<img src="vaish2.png" /></br>

Here</br>
Version: Identifies the RTP version which is the same for all the RTCP packets</br>
P-Padding: When set, this RTCP packet contains some additional padding octets in the end.</br>
RC-Reception report count: The number of reception report blocks being sent in this packet.</br>
Packet Type: Packet type will define the type of the RTCP message that is being transmitted.</br>
Length: The length of the RTCP packet being sent.</br>

<p>The entire RTCP packet header is abstracted in the class RTCPCommonHeader class. All the different messages will have to
create one instance of this RTCP header by providing the information like the type of the packet and the length of the packet
being sent. This class will encapsulate the information in a 32 bit value and return the first common header 4 byte header for
all the RTCP packets.<p>

<b>1. Receiver Report Message (RR Message):</b></br>
<img src="vaish3.png" /></br>

<p>One of the primary uses of RTCP is reception quality reporting. The reception quality reporting is done through the RR report
message. This RR message is sent to all the participants who receive data from this sender.</p>

<p>RR message also follows the common header structure as followed by all other RTCP messages. The Packet type for the RTCP message will be of value 201. A receiver report packet will cotain the SSRC of the participant who is sending the report. As in our implementaion there could be only one sender for each instance of the library, the SSRC of the RTP session will be used.</p>

<p>In the report block the reception quality of a single synchronization source from which the reporter has received RTP packets
during the current reporting interval. The reportee SSRC identifies the participant to whom this report block pertains. The
statistics in the report block denote the quality of reception for the reportee synchronization source, as received at the
participant generating the RR packet.</p>

<p>The cumulative number of the packet lost count will give the total number of packets lost from that particular source over the
interval of the time since the last RR packet was sent. Here only 24 bits are being used for the sending of the cumulative number
of packet lost. The packet lost count is calculated at the RTPSession class where the statistics of the total number of packets 
lost will be maintained for every participant.</p>

<p>The extended sequence number is the highest sequence number received in the RTP data packet from that SSRC. Latest received 
sequence number will be maintained from the latest packet received from that particular source SSRC.</p>

<p>The Last Sender report (LSR) timestamp is the timestamp value of the last RTCP SR packet received from the reportee SSRC.
The delay since last sender report(DLSR) is the delay, expressed in the units of time between the last SR packet from the reportee
SSRC.</p>

<p>The RR message packet has been abstracted in the class RTCPRRPkt and the sender thread for sending of the RR packet is 
RTCPRRSendThread class. This RTCPRRSendThread will send the packets at the interval of 8 seconds.</p>

<b>2. Sender Report Message (SR Message):</b></br>
<img src="vaish4.png" /></br>

<p>In addition to the sending of the report about the receivers, RTCP also sends packets about itself to other participants.
The SR packet format is very simple interms of the data transmitted. The common RTCP header is created using RTCPCommonHeader class and the Packet type for the sR message is 200. As there could be only one sender for every instance of the library, there will be only one Sender Report block.

<p>The Reporter SSRC will have the SSRC number of the session that is sending out the SR packet. The NTP timestamp indicates
the absloute time at which the packet was sent. The RTP timestamp corresponds to the same value of the RTP timestamp as the next sending RTP message would have posssibly had in it's header. The value is not of the previous packet sent, but the value of the next possibly sent RTP packet.</p>

<p>The sender packet count and sender octet count will have the total number of the packets sent since the last time, the
SR report message was sent out to the participants.</p>

<p>The SR RTCP packet is abstracted in the form of class RTCPSenderReport, where all the statistics of the sent data will be
collected and periodically the data will be sent out using RTCPSRSendThread class.</p>

<b>3. RTCP SDES message:</b></br>
<p>RTCP convey the Source description (SDES) packets that provide participant identification and supplementary details, such
as the CNAMe, e-mail addresses and other details. SDES packet also contains the common header format as followed by other RTCP
messages. The content part in this implementation will only carry the CNAME corresponding the sender in the RTP session along with
the matching sSRC number of the sender. In our implementaion of the RTP library, we will accept the packets from all unknown sources. As the packets are not from known sources, the SSRC of these packets will not be there in the Participant database. So by sending in the SDES message periodically, the participant database of all the participants will be maintained. The SDES mesage will be sent out to all the participants in the group once every 10 seconds. The SDES message is abstracted in the form of the RTCPSDESHeader class, where the CNAME of the sender is encapsulated in the format of Tag Length Value. Where the Tag specifies that this is of content type CNAME and the next 32 bits will convey the lenght of the CNAME.</p>

<b>4. RTCP BYE message:</b></br>
<p>As RTCP is a session control protocol, it will maintain the states of the session between the participanting entities. 
A BYE packet is generated when a participant leaves the session, or when it changes its SSRC number due to a collision. An interface has been provided in the RTPSession class for the application to send BYE message to any of the know participants.The structure of the BYE message is very simple, it follows the common header format as followed by other RTCP messages. The Packet
Type value for the BYE message is 203. The length of the encapsulated packet will be number of SSRC values that it will be sent in the packet. BYE message will encapsulate the SSRC values of the sessions to be closed.</p>

<h3><a name="api">Advanced Programming Interface (API)</a></h3>
Please refer to the <a href="API">automatically generated JavaDocs</a>.

<h3><a name="example_application">Example Application</a></h3>
<table border="0" cellspacing="2">
<tr><td>&nbsp;</td><td>The example below illustrates the simplest usage of the library.</td></tr>
<tr><td valign="top">1)</td><td>The class implements the callback interface RTPAppIntf, and defines
	the necessary function "receiveData".</td></tr>
<tr><td valign="top">2)</td><td>The implementation of receiveData just prints the received data.</td></tr>
<tr><td valign="top">3)</td><td>In main(), one object of the class is instantiated.</td></tr>
<tr><td valign="top">4)</td><td>A new RTP session is created.</td></tr>
<tr><td valign="top">5)</td><td>The application registers with the RTPSession.</td></tr>
	In the process, UDP ports 4545 and 4546 are used for RTP and RTCP respectively,
	and our cname is set to "MyCname".</td></tr>
<tr><td valign="top">6)</td><td>Next a participant is created. His name is "Cname", his ip-address is the looopback
	interface, his RTP port is 4545 and his RTCP port is 4546. By defaul, this
	participant is both a receiver and a sender. Of course, this is just us.</td></tr>
<tr><td valign="top">7)</td><td>The participant is added to the session.</td></tr>
<tr><td valign="top">8)</td><td>We enter an infinite loop where we constantly send the string "123" to ourselves.</td></tr>
<tr><td valign="top">9)</td><td>receiveData will repeatedly be called and write out "I received 123 from MyCname".</td></tr>
<tr><td valign="top">&nbsp;</td><td>&nbsp;</td></tr>
<tr><td>&nbsp;</td><td>	
Import jlibrtp.*;</br>
<b>public AnExample implements RTPAppIntf {</b></br>
&nbsp;&nbsp;  RTPSession session = null;</br>
&nbsp;&nbsp;  <b>Public void receiveData(byte[] data, String cname, long time) {</b></br>
&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;I received &quot; + (new String(data)) + &quot;from &quot;+ cname); </br>
&nbsp;&nbsp;  <b>}</b></br>
&nbsp;&nbsp;  Public AnExample() { }</br>
&nbsp;&nbsp;  <b>public static void main(String [] args) {</b></br>
&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;AnExample example = new AnExample();</br>
&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;example.session = new RTPSession();</br>
&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;example.session.RTPSessionRegister(4545,4546,&quot;MyCname&quot;,111);</br>
&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;Participant p = new Participant(&quot;Cname&quot;,&quot;127.0.0.1&quot;,4545,4546);</br>
&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;example.session.addParticipant(p);</br>
&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;String str = &quot;123&quot;;</br>
&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;while(true) { session.sendData(str.getBytes()) }</br>
&nbsp;&nbsp;<b>}</b></br>
<b>}</b></br>
</td></tr></table>
<h3><a name="demo_application">Demonstration Application</a></h3>
<p>The source code includes receiverDemo.java and senderDemo.java. They are 
designed to stream 8kHz PCM mono sound from the sender to the receiver. Note 
that it is difficult to stream sound files in Java, the timer is not accurate 
enough to ensure timely tranmission and the Java Media Framework does not guarantee 
that the receiver will block, when writing to the sound stream, if the packets 
arrive too quickly. One way to fix this is to also play the sound on the sender, 
which ensures that it blocks for the right amount of time before sending the next packet.</p> 
<p>Readers are encouraged to look at them and modify them, certain parameters 
(such as audio-format) have been hardcoded intentionally to limit the number of 
parameters (and sources of confusion) that are needed. Running the program without
any parameters explains the required parameters.</p>

<h3><a name="security">Security</a></h3>
Java inherently provides some protection against buffer overflows and other common problems. 
Additionally, packet buffer size is automatically limited to 2000 octets. Developers / users can 
choose whether packets from unknown sources should be returned to the application or discarded.

Our library does not implement encryption according to the Secure RTP (SRTP, RFC)[] specifications, 
and therefore provides no confidentiality. All streams can be played by anyone able to intercept the packets.

<h2><a name="measurements">Measurements</a></h2>
<h3><a name="interoperability">Interoperability</a></h3>
The library has been validated in three ways. First, we have looped packets through the library to 
verify that the parsing is correct

<h3><a name="performance">Performance</a></h3>
We tested the library by streaming raw audio (44.1kHz, 16 bit, stereo, 1kbyte packets) across the loopback interface, 
i.e. the same instance of the library was both sending and receiving. The test system (2.13 GHz, 
Linux 2.6.17, Java 1.5.0) had no problems handling the 2.8 Mbps. While packet parsing is expensive 
in Java, due to lack of pointers and unsigned integers, this would be more than sufficient to stream video.



</p><h2><a name="task_list">Task List</a></h2>
<table border="0" cellpadding="2">
<tr><td><b>Code:</b></td><td></td></tr>
<tr><td valign="top">Vaishnav:</td><td> 	RTCPSession, RTCP Packet parsers, RTCP Receiver Report and threads, 
			RTCP Sender Report and threads, RTCP SDES header, RTCP test application</td></tr>
<tr><td valign="top">Arne:</td><td>  		RTP Packet parser, RTPSession, RTP Receiver Thread, Application Callback Thread, 
			PacketBuffer, Frame, Participant database, RTPAppIntf, Sound Demo Application</td></tr>
<tr><td>Shared:</td><td> 	Participant, Integer <-> Binary conversion methods (StaticProcs)</td></tr>
<tr><td></td><td></td></tr>
<tr><td><b>Report:</b></td><td></td></tr>
<tr><td>Vaishnav: </td><td>RTCP description</td></tr>
<tr><td>Arne:</td><td>		Rest</td></tr>
</table>

<p>Classes are marked with the @author tag. The sender and receiver demo programs 
were initially based on "Java play WAV sound file",  a tutorial on AnyExample.com<a href="#5">[7]</a>. 
Except for this, all code is original work.</p>

</p><h2><a name="references">References</a></h2>
<dl compact="compact">
<dt><a name="1">1</a></dt>
<dd>IETF, <em><a href="http://www.ietf.org/rfc/rfc3550.txt">RFC 3550, Real-Time Transport Protocol</a></em></dd>
<dt><a name="2">2</a></dt>
<dd>Sun Microsystems, <em><a href="http://java.sun.com/products/java-media/jmf/index.jsp">Java Media Framework</a></em></dd>
<dt><a name="3">3</a></dt>
<dd>GNU / Free Software Foundation, <em><a href="http://www.gnu.org/licenses/lgpl.html">GNU Lesser General Public License</a></em></dd>
<dt><a name="4">4</a></dt>
<dd>Thomas Peuker, <em><a href="http://www4.informatik.uni-erlangen.de/Projects/JRTP/">JRTP</a></em>, University of Erlangen-Nuernberg, Germany</dd>
<dt><a name="5">5</a></dt>
<dd>Waqar Ali, Akhil Nigam, <em><a href="http://www.cs.columbia.edu/~hgs/teaching/ais/1998/projects/java_rtp/report.html">java.net.rtp</a></em>, Columbia University, NY, USA</dd>
<dt><a name="6">6</a></dt>
<dd>GNU Telephony, <em><a href="http://www.gnu.org/software/ccrtp/">ccRTP</a></em></dd>
<dt><a name="7">7</a></dt>
<dd>AnyExample.com, <em><a href="http://www.anyexample.com/programming/java/java_play_wav_sound_file.xml">Java play WAVA Sound file</a></em></dd>
</dl>
<hr>
Last updated:  2006-12-18 by <a href="http://kepp.net">Arne Kepp</a>
</body></html>
